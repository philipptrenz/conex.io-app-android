/**
 * conex.io REST-Like API
 * The conex.io API provides the functionality to interact with home automation devices, which are connected to a home automation server, detached from the manufacturer specific communication syntax.
 * <p>
 * OpenAPI spec version: 0.9.5
 * <p>
 * <p>
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.swagger.client;

import android.util.Log;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.reflect.TypeToken;

import java.lang.reflect.Array;
import java.lang.reflect.Type;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Date;
import java.util.Map;
import java.util.TimeZone;

import io.swagger.client.model.*;

public class JsonUtil {
    public static GsonBuilder gsonBuilder;

    public static final Class<? extends Function>[] functionSubclasses = new Class[] {

            OnOff.class,
            Dimmer.class,
            Temperature.class

    };

    public static String getFunctionId(Function f) {
        for (Class clazz : JsonUtil.functionSubclasses) {
            try {
                clazz.cast(f);
            } catch (Exception e) {
                continue;
            }
            return getJsonFunctionId(clazz);
        }
        return getJsonFunctionId(Function.class);
    }

    private static String getJsonFunctionId(Class<? extends Function> clazz) {
        return clazz.getSimpleName().toLowerCase();
    }


    static {

    /*
     * Added RuntimeTypeAdapterFactory for polymorphic deserialization of json for functions
     * Add new functions with their function_id here!
     */
        RuntimeTypeAdapterFactory<Function> typeFactory = RuntimeTypeAdapterFactory
            .of(Function.class, "function_id")
            // Here you specify which is the parent class and what field particularizes the child class.
            .registerSubtype(Function.class, "function")
            .registerSubtype(OnOff.class, "onoff") // if the flag equals the class name, you can skip the second parameter. This is only necessary, when the "type" field does not equal the class name.
            .registerSubtype(Dimmer.class, "dimmer")
            .registerSubtype(Temperature.class, "temperature");

        gsonBuilder = new GsonBuilder();
        gsonBuilder.serializeNulls();
        gsonBuilder.setDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ");

        /*
         * Needed to create own deserialize method for time mapping
         */
        gsonBuilder.registerTypeAdapter(Date.class, new JsonDeserializer<Date>() {
            public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {
                String date = json.getAsString();
                SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'");
                //format.setTimeZone(TimeZone.getTimeZone("GMT"));

                try {
                    return format.parse(date);
                } catch (ParseException exp) {
                    Log.e("Failed to parse Date:", exp.getMessage());
                    return null;
                }
            }
        });
        gsonBuilder.registerTypeAdapterFactory(typeFactory);

    }

    public static Gson getGson() {
        return gsonBuilder.create();
    }


    /*
     * Created second GSON for serialization because RuntimeTypeAdaptorFactory crashes with function_id serialization
     */
    public static Gson getGson2() {
        GsonBuilder gsonBuilder2 = new GsonBuilder();
        gsonBuilder2.serializeNulls();
        gsonBuilder2.setDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ");

        /*
         * Needed to create own deserialize method for time mapping
         */
        gsonBuilder2.registerTypeAdapter(Date.class, new JsonDeserializer<Date>() {
            public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {
                String date = json.getAsString();
                SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'");
                //format.setTimeZone(TimeZone.getTimeZone("GMT"));

                try {
                    return format.parse(date);
                } catch (ParseException exp) {
                    Log.e("Failed to parse Date:", exp.getMessage());
                    return null;
                }
            }
        });

        return gsonBuilder2.create();
    }

    public static String serialize(Object obj) {
        return getGson2().toJson(obj);
    }

    public static <T> T deserializeToList(String jsonString, Class cls) {
        return getGson().fromJson(jsonString, getListTypeForDeserialization(cls));
    }

    public static <T> T deserializeToObject(String jsonString, Class cls) {
        return getGson().fromJson(jsonString, getTypeForDeserialization(cls));
    }

    public static Type getListTypeForDeserialization(Class cls) {
        String className = cls.getSimpleName();

        if ("Device".equalsIgnoreCase(className)) {
            return new TypeToken<List<Device>>() {
            }.getType();
        }

        if ("Devices".equalsIgnoreCase(className)) {
            return new TypeToken<List<Devices>>() {
            }.getType();
        }

        if ("Dimmer".equalsIgnoreCase(className)) {
            return new TypeToken<List<Dimmer>>() {
            }.getType();
        }

        if ("Filter".equalsIgnoreCase(className)) {
            return new TypeToken<List<Filter>>() {
            }.getType();
        }

        if ("Function".equalsIgnoreCase(className)) {
            return new TypeToken<List<Function>>() {
            }.getType();
        }

        if ("Ids".equalsIgnoreCase(className)) {
            return new TypeToken<List<Ids>>() {
            }.getType();
        }

        if ("OnOff".equalsIgnoreCase(className)) {
            return new TypeToken<List<OnOff>>() {
            }.getType();
        }

        if ("Patcher".equalsIgnoreCase(className)) {
            return new TypeToken<List<Patcher>>() {
            }.getType();
        }

        if ("Temperature".equalsIgnoreCase(className)) {
            return new TypeToken<List<Temperature>>() {
            }.getType();
        }

        return new TypeToken<List<Object>>() {
        }.getType();
    }

    public static Type getTypeForDeserialization(Class cls) {
        String className = cls.getSimpleName();

        if ("Device".equalsIgnoreCase(className)) {
            return new TypeToken<Device>() {
            }.getType();
        }

        if ("Devices".equalsIgnoreCase(className)) {
            return new TypeToken<Devices>() {
            }.getType();
        }

        if ("Dimmer".equalsIgnoreCase(className)) {
            return new TypeToken<Dimmer>() {
            }.getType();
        }

        if ("Filter".equalsIgnoreCase(className)) {
            return new TypeToken<Filter>() {
            }.getType();
        }

        if ("Function".equalsIgnoreCase(className)) {
            return new TypeToken<Function>() {
            }.getType();
        }

        if ("Ids".equalsIgnoreCase(className)) {
            return new TypeToken<Ids>() {
            }.getType();
        }

        if ("OnOff".equalsIgnoreCase(className)) {
            return new TypeToken<OnOff>() {
            }.getType();
        }

        if ("Patcher".equalsIgnoreCase(className)) {
            return new TypeToken<Patcher>() {
            }.getType();
        }

        if ("Temperature".equalsIgnoreCase(className)) {
            return new TypeToken<Temperature>() {
            }.getType();
        }

        return new TypeToken<Object>() {
        }.getType();
    }

};
